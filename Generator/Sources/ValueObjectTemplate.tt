<#@ template language="C#" visibility="internal" linePragmas="false" #>
//
// Generated by ValueObjectGenerator
// DO NOT EDIT THIS FILE
//
using System;
using System.Diagnostics.CodeAnalysis;

<#
    ValueName = ValueName.Replace( "\"", "" );
    var declarationType = "class";
    if( IsStruct )
    {
        declarationType = "struct";
    }

    var requireNonEmptyString = NonEmptyString;
    var requireEmptyString = EmptyString;
    var requireNonNegative = NonNegative;
    var requireMinMax = !string.IsNullOrEmpty( Min ) && !string.IsNullOrEmpty( Max );
    var requireValidateMethod =
        !requireNonEmptyString &&
        !requireEmptyString &&
        !requireNonNegative &&
        !requireMinMax &&
        !ValueOption.HasFlag( ValueOption.NonValidating );

#>
<# if( !string.IsNullOrEmpty( Namespace ) ) { #>
namespace <#= Namespace #>
{
<# } #>
    public partial <#= declarationType #> <#= Name #> : IEquatable<<#= Name #>><#= ValueOption.HasFlag( ValueOption.Comparable ) ? $", IComparable<{Name}>" : "" #>
    {
        public <#= BaseTypeName #> <#= ValueName #> { get; }

        public <#= Name #>( <#= BaseTypeName #> value )
        {
<# /* Empty String */ #>
<# if( requireNonEmptyString ) { #>
            if( value.Trim().Length == 0 )
            {
                throw new ArgumentException( $"(<#= Name #>) : value is empty string" );
            }
            <#= ValueName #> = value;
<# } else if( requireEmptyString ) { #>
            <#= ValueName #> = value.Trim().Length == 0 ? string.Empty : value;
<# /* Non-Negative */ #>
<# } else if( requireNonNegative ) { #>
            if( value < 0 )
            {
                throw new ArgumentException( $"(<#= Name #>) : value is negative {value}" );
            }
            <#= ValueName #> = value;
<# /* Min, Max */ #>
<# } else if( requireMinMax ) { #>
            if( value < (<#= Min #>) || value > (<#= Max #>) )
            {
                throw new ArgumentOutOfRangeException( $"<#= Name #> : {value} (range:<#= Min #> < <#= Max #>)" );
            }
            <#= ValueName #> = value;
<# /* No Validation */ #>
<# } else if( !requireValidateMethod ) { #>
            <#= ValueName #> = value;
<# } else { #>
            <#= ValueName #> = Validate( value );
<# } #>
        }

<# /* Validate method */ #>
<# if( requireValidateMethod ) { #>
        private static partial <#= BaseTypeName #> Validate( <#= BaseTypeName #> value );
<# } #>

<# /* ToString */ #>
<# if( !ValueOption.HasFlag( ValueOption.ToString ) ) { #>
        //
        // Default ToString()
        //
        public override string ToString()
        {
            return <#= ValueName #>.ToString();
        }
<# } else { #>
        //
        // Custom ToString()
        //
        private partial string ToStringImpl();

        public override string ToString()
        {
            return ToStringImpl();
        }
<# } #>

        //----------------------------------------------------------------------
        // Equality
        //----------------------------------------------------------------------
        public bool Equals( <#= IsClass ? "[AllowNull] " : "" #><#= Name #> other )
        {
<# if( IsClass ) { #>
            if( ReferenceEquals( null, other ) )
            {
                return false;
            }

            if( ReferenceEquals( this, other ) )
            {
                return true;
            }
            return <#= ValueName #> == other.<#= ValueName #>;
<# } else if( IsStruct ) { #>
            return Equals( <#= ValueName #>, other.<#= ValueName #> );
<# } #>
        }

        public override bool Equals( [AllowNull] object obj )
        {
<# if( IsClass ) { #>
            if( ReferenceEquals( null, obj ) )
            {
                return false;
            }

            if( ReferenceEquals( this, obj ) )
            {
                return true;
            }

            if( obj.GetType() != this.GetType() )
            {
                return false;
            }

            return Equals( (<#= Name #>)obj );
<# } else if( IsStruct ) { #>
            return obj is <#= Name #> other && Equals( other );
<# } #>
        }

        // HashCode
        public override int GetHashCode() => <#= ValueName #>.GetHashCode();

        // Operator ==, !=
        public static bool operator ==( <#= Name #> a, <#= Name #> b )
        {
<# if( IsClass ) { #>
            if( ReferenceEquals( a, b ) )
            {
                return true;
            }

            return a?.Equals( b ) ?? ReferenceEquals( null, b );
<# } else if( IsStruct ) { #>
            return a.Equals( b );
<# } #>
        }

        public static bool operator !=( <#= Name #> a, <#= Name #> b )
        {
            return !( a == b );
        }

        //----------------------------------------------------------------------
        // <#= ValueOption.HasFlag( ValueOption.Implicit ) ? "Implicit" : "Explicit" #>
        //----------------------------------------------------------------------
        public static <#= ValueOption.HasFlag( ValueOption.Implicit ) ? "implicit" : "explicit" #> operator <#= BaseTypeName #>( <#= Name #> x )
        {
            return x.<#= ValueName #>;
        }

        public static implicit operator <#= Name #>( <#= BaseTypeName #> value )
        {
            return new <#= Name #>( value );
        }

<# if( ValueOption.HasFlag( ValueOption.Comparable ) ) { #>
        //----------------------------------------------------------------------
        // Comparable
        //----------------------------------------------------------------------
        public int CompareTo( <#= Name #> other )
        {
            if( ReferenceEquals( this, other ) )
            {
                return 0;
            }

            if( ReferenceEquals( null, other ) )
            {
                return 1;
            }

            return <#= ValueName #>.CompareTo( other.<#= ValueName #> );
        }
<# } #>

    }

<# if( !string.IsNullOrEmpty( Namespace ) ) { #>
}
<# } #>
